\subsection{Algoritmo Implementado}

Para resolver el problema de CMF de forma exacta, generamos un algoritmo encargado de recorrer todas las posibles cliques del grafo de entrada con la estrategia de $Backtracking$. Esto se debe a que no hallamos ninguna caracterización particular que nos permitiera reducir el espacio de búsqueda de cliques tal que el algoritmo ignorara una cantidad asintótica de ellas. Luego, nuestra implementación genera todas las soluciones posibles siguiendo un orden lexicográfico para evitar repetirlas. Por ejemplo, la clique $k_{2}$ formada por los nodos \{1,2\} es la misma que se forma al elegir los nodos \{2,1\}. Por lo tanto, al representar los nodos como números y formar cliques respetando su orden lexicográfico, nos ahorramos realizar repeticiones como la mencionada. 

De este modo, nuestro algoritmo comienza generando todas las cliques que contienen al nodo de menor valor numérico que no haya sido utilizado y, en cada paso, selecciona una serie de candidatos a ser agregados a la clique actual hasta que no quede ninguno. Una vez alcanzada dicha instancia, el algoritmo retrocede quitando el último nodo agregado a la clique e insertando al próximo candidato, si es que existe. El orden lexicográfico se respeta al momento de elegir los candidatos ya que sólo pueden ser seleccionados como tales aquellos cuyo valor representativo sea mayor al del último nodo agregado a la clique.

A continuación, se expone el pseudocódigo del algoritmo mencionado:\\

\underline{Variables globales:} \textbf{Conj(nodo)} $cliqueMaxima$, \textbf{Entero} $fronteraMaxima$.\\

\begin{algorithm}[H]
	\SetAlgoLined
	\caption{Algoritmo Exacto}
	\KwIn{\textbf{Grafo} $g$}
	\KwOut{\textbf{Conj(nodo)} $clique$}

	\textbf{Conj(nodo)} $clique = \emptyset$\\
	\textbf{Conj(nodo)} $candidatos = $ nodos($g$)\\

	Backtracking($clique$, $candidatos$)\\

	\textbf{devuelvo} $cliqueMaxima$\\

\end{algorithm}

\begin{algorithm}[H]
	\SetAlgoLined
	\caption{Backtracking}
	\KwIn{\textbf{Conj(nodo)} $clique$, \textbf{Conj(nodo)} $candidatos$, \textbf{Grafo} $g$} %esto hay que ponerlo bien
	\KwOut{\textbf{Conj(nodo)} $clique$}

	\For{$c \in candidatos$}{
		\If{\textbf{frontera}($ clique \cup \{c\} $) $> fronteraMaxima$ }{
			$cliqueMaxima = clique \cup \{c\} $\\
			$fronteraMaxima = $frontera($clique \cup \{c\}$)\\
		}
		\If{\textbf{frontera}($ clique \cup \{c\} $) $>$ \textbf{frontera}($clique$)}{
			Backtracking($ clique \cup \{c\} $, calcularCandidatos($ clique \cup \{c\} $), $g$, $c$)\\
		}
	}
\end{algorithm}

\begin{algorithm}[H]
	\SetAlgoLined
	\caption{frontera}
	\KwIn{\textbf{Conj(nodo)} $clique$, \textbf{Grafo} $g$} %esto hay que ponerlo bien
	\KwOut{\textbf{Entero} $res$}

	$res = 0$\\
	\For{\textbf{nodo} $v \in nodos(g)$}{
		$res = res + (\#adyacentes(v) - (\#clique - 1))$\\
	}

	\textbf{devuelvo} $res$\\

\end{algorithm}

\begin{algorithm}[H]
	\SetAlgoLined
	\caption{calcularCandidatos}
	\KwIn{\textbf{Conj(nodo)} $clique$, \textbf{Grafo} $g$, \textbf{Nodo} $ultimoNodoAgregado$} %esto hay que ponerlo bien
	\KwOut{\textbf{Conj(nodo)} $candidatos$}

	nodo $w$ = elemento de la $clique$\\

	$candidatos = adyacentes(w)$\\
	\ForAll{$v \in nodos(g)$ con $v \neq w$}{
		$candidatos$ = interseccion entre $adyacentes(v)$ y $candidatos$\\
	}

	quitar de $candidatos$ todos los nodos de valor menor a $ultimoNodoAgregado$

	\textbf{devuelvo} $candidatos$\\

\end{algorithm}

Nuestro programa comienza con la función $Algoritmo\ Exacto$ que se encarga de inicializar los valores con los que se llama a $Backtracking$. A su vez, esta última realiza las llamadas recursivas necesarias para ir buscando las diferentes cliques y sus candidatos, teniendo en cuenta el orden lexicográfico mencionado anteriormente. Al realizar dicho procedimiento, el algoritmo verifica, en cada paso, que las cliques que va considerando sean mejores que la mejor encontrada hasta el momento. Si esto no ocurre, quita el nodo en cuestión y deja de explorar cliques conteniéndolo.\\
\newline
Luego, la función $calcularCandidatos$ busca aquellos nodos no contenidos en la clique en exploración pero conectados con todos los que se encuentran en ella. Dicho procedimiento se logra encontrando la intersección entre todos los nodos adyacentes a los nodos de la clique mencionada.\\
\newline
Por otro lado, la función $frontera$ devuelve la cantidad de aristas de la frontera de una clique. Para efectuar dicho cálculo, se realiza la resta de la cantidad de nodos adyacentes a cada nodo de la clique menos la cantidad de nodos de ésta menos 1, o sea ($\forall v \in clique$) $\#adyacentes(v)-(\#nodos(clique)-1)$. La precondición de $frontera$ consiste en un conjunto de nodos todos adyacentes entre sí. 

\subsection{Análisis de complejidad}

La complejidad temporal del algoritmo exacto realizado se encuentra acotada por la complejidad de la función de $Backtracking$. Ésta se puede analizar a partir del árbol de soluciones del problema en cuestión. Donde cada nodo de dicho árbol representa a una clique cuya cantidad de nodos se encuentra determinada por el nivel en el que éste se ubica. Luego, la raíz es el único caso posible de 0 nodos. El primer nivel presenta todas las posibles cliques conteniendo un único nodo y así sucesivamente con todas las posibles combinaciones. Dado que buscamos cliques compuestas por 1 a $n$ nodos, encontrar las de tamaño $k$, con $k\leq n$, tiene un costo de $\mathcal{O}({n \choose k})$ = $\mathcal{O}(\frac{n!}{(n-k)!*k!})$, siendo $\frac{n!}{(n-k)!*k!} \leq n^k$. Luego, la cantidad de pasos de dicho procedimiento resulta $\sum\limits_{i=1}^n {n \choose i} = 2^n - 1$. 

Es entonces que podemos determinar que la complejidad de nuestro algoritmo exacto resulta $\mathcal{O}(2^n - 1) +\ costo\ de\ realizar\ cada\ paso$.

Veamos cuál es el costo de realizar cada paso:
\begin{itemize}
\item La función $frontera$ realiza un ciclo con la cantidad de nodos, $\mathcal{O}(n)$, que es calculada con $size()(\mathcal{O}(1))$\footnote{http://www.cplusplus.com/reference/vector/vector/size/}. En dicho ciclo, se le suma a un entero ($res$) el valor de un vector ($g$) al que se accede para, luego, acceder a otro ($nodos$) y se le resta 1 a este último. Esto se realiza en $\mathcal{O}(1)*\mathcal{O}(1)$\footnote{http://www.cplusplus.com/reference/vector/vector/operator[]/} = $\mathcal{O}(1)$. Luego, la complejidad de dicha función resulta $\mathcal{O}(n)*\mathcal{O}(1)$ = $\mathcal{O}(n)$.
\item Por otro lado, la función $interseccionNAdyacentes$ comienza creando un vector ($v\_interseccion$), cuya complejidad temporal es $\mathcal{O}(n)$\footnote{http://www.cplusplus.com/reference/vector/vector/vector/} pues consiste en un constructor por copia, y un vector $v\_tmp$ por default en $\mathcal{O}(1)$. Luego, realiza un ciclo iterando la cantidad de nodos ($indices$) recibidos por parámetro, siendo $\#indices \leq n$. En dicho ciclo, ejecuta la función $set_intersection$ ($\mathcal{O}(2*($n$+$n$)-1)$\footnote{http://www.cplusplus.com/reference/algorithm/set_intersection/?kw=set_intersection}) de los primer ($begin()$ que se realiza en $\mathcal{O}(1)$\footnote{http://www.cplusplus.com/reference/vector/vector/begin/}) y último ($end()$ que se realiza en $\mathcal{O}(1)$http://www.cplusplus.com/reference/vector/vector/end/) elementos del vector $v_interseccion$ y el inicio y fin del $i$-ésimo . 
\end{itemize}
































