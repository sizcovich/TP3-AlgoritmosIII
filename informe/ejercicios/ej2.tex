\subsection{Algoritmo Implementado}

Para la resolución exacta del problema a resolver, realizamos un algoritmo que recorriera todas las posibles cliques del grafo de entrada. Esto se debió a que no hallamos ninguna caracterización que nos permitiera reducir el espacio de búsqueda de cliques para que el algoritmo ignorara una cantidad asintótica de ellas. Luego, nuestra implementación genera todas las soluciones siguiendo un orden lexicográfico para evitar repetir ejecuciones. Por ejemplo, la clique $k_{2}$ formada por los nodos \{1,2\} es la misma que se forma al elegir los nodos \{2,1\}. De esta forma, al representar los nodos como números y formar cliques respetando su orden lexicográfico, nos ahorramos pasar por soluciones que ya formamos antes. %para mi hay que decir que chequea si ya lo ejecuto, porque el orden lexicografico solo me dice cual va a verificar primero...

Luego, nuestro algoritmo comienza generando todas las cliques que contienen al nodo de menor valor numérico que no haya sido utilizado y, en cada paso, va a seleccionar una serie de candidatos a extender la clique actual hasta no encontrar más y volver hacia atras, quitando el último nodo que se agregó a la clique, y eligiendo el próximo nodo que sea candidato si es que lo hubiera. El orden lexicografico es garantizado al momento de elegir los candidatos, ya que solo elegira aquellos candidatos cuyo numero de nodo sea mayor al numero de nodo del ultimo nodo que fue agregado a la clique.

A continuación, se expone el pseudocódigo del algoritmo:

Variables globales: \textbf{Conj(nodo)} $cliqueMaxima$, \textbf{Entero} $fronteraMaxima$.\\

\begin{algorithm}[H]
	\SetAlgoLined
	\caption{Exacto}
	\KwIn{\textbf{Grafo} $g$} %esto hay que ponerlo bien
	\KwOut{\textbf{Conj(nodo)} $clique$}

	\textbf{Conj(nodo)} $clique = \emptyset$\\
	\textbf{Conj(nodo)} $candidatos = $ nodos($g$)\\

	Backtracking($clique$, $candidatos$)\\

	\textbf{devuelvo} $cliqueMaxima$\\

\end{algorithm}

\begin{algorithm}[H]
	\SetAlgoLined
	\caption{Backtracking}
	\KwIn{\textbf{Conj(nodo)} $clique$, \textbf{Conj(nodo)} $candidatos$, \textbf{Grafo} $g$} %esto hay que ponerlo bien
	\KwOut{\textbf{Conj(nodo)} $clique$}

	\For{$c \in candidatos$}{
		\If{\textbf{frontera}($ clique \cup \{c\} $) es mayor a $fronteraMaxima$ }{
			$cliqueMaxima = clique \cup \{c\} $\\
			$fronteraMaxima = $frontera($clique \cup \{c\}$)\\
		}
		\If{\textbf{frontera}($ clique \cup \{c\} $) $>$ \textbf{frontera}($clique$)}{
			Backtracking($ clique \cup \{c\} $, calcularCandidatos($ clique \cup \{c\} $), $g$, $c$)\\
		}
	}
\end{algorithm}

\begin{algorithm}[H]
	\SetAlgoLined
	\caption{frontera}
	\KwIn{\textbf{Conj(nodo)} $clique$, \textbf{Grafo} $g$} %esto hay que ponerlo bien
	\KwOut{\textbf{Entero} $res$}

	$res = 0$\\
	\For{\textbf{nodo} $v \in nodos(g)$}{
		$res = res + (\#adyacentes(v) - (\#clique - 1))$\\
	}

	\textbf{devuelvo} $res$\\

\end{algorithm}

\begin{algorithm}[H]
	\SetAlgoLined
	\caption{calcularCandidatos}
	\KwIn{\textbf{Conj(nodo)} $clique$, \textbf{Grafo} $g$, \textbf{Nodo} $ultimoNodoAgregado$} %esto hay que ponerlo bien
	\KwOut{\textbf{Conj(nodo)} $candidatos$}

	nodo $w$ = un elemento de $clique$\\

	$candidatos = adyacentes(w)$\\
	\For{\textbf{todo nodo} $v \in nodos(g), v \neq w$}{
		$candidatos$ = interseccion entre $adyacentes(v)$ y $candidatos$\\
	}

	quitar de $candidatos$ todos los nodos menores numericamente a $ultimoNodoAgregado$

	\textbf{devuelvo} $candidatos$\\

\end{algorithm}

En este caso el programa comienza con la funcion Exacto, esta es la encargada de crear los valores inciales con los cuales se va a llamara a la funcion backtracking, luego esta hace las llamdas recursivas para ir creando las diferentes cliques y sus candidatos teniendo en cuenta el orden lexicografico y en cada paso chequeando si las cliques que considera son mejores que la mejor encontrada actualmente. \\
La funcion $calcularCandidatos$ busca aquellos nodos que no son los de la clique actual pero que estan conectados con todos ellos, eso se logra calculando la interseccion entre los nodos adyacentes a los nodos de la clique. \\
La funcion $frontera$ devuelve el valor numerico de la frontera de una clique, como tenemos por pre-condicion que todo conjunto de nodos que reciba como parametro la funcion es una clique, entonces calcular la frontera se puede hacer restandole a la cantidad de nodos adyacentes de cada nodo la cantidad de nodos de la clique menos 1. 

\subsection{Análisis de complejidad}

El analisis de complejidad del algoritmo posee una cota superior definida por la funcion recursiva de backtracking, esta funcion se pueden analizar calcular el arbol de soluciones del problema en cuestion. Como buscamos cliques y puede haber cliques de tamaño 1 hasta tamaño $n$ inclusive, entonces el arbol de soluciones va a tener un tamaño de 