\subsection{Algoritmo Implementado}

Nuestro algoritmo encuentra la solucion al problema de CMF recorriendo todas las posibles cliques dentro de un grafo. Esto fue inevitable ya que no encontramos ninguna caracterizacion que nos permita hacer ua reduccion del espacio de busqueda de cliques en el grafo de tal que el algoritmo pudiera ignorar una cantidad asintotica de cliques.

Entonces nuestro algoritmo va a generar todas las soluciones en un orden lexicografico, esto lo hacemos para evitar formar cliques que ya hayamos formado anteriormente (por ejemplo la clique $k_{2}$ formada por los nodos \{1,2\} es la misma clique que se forma cuando eligamos los nodos \{2,1\}), De esta forma, si numeramos los nodos y formamos cliques en orden lexicografico con respecto a la numeracion de ellos nos ahorramos pasar por soluciones que ya formamos antes.

Luego nuestro algoritmo comienza generando todas las cliques que contengan al menor nodo numerado que no haya sido utilizado y en cada paso va seleccionar una serie de candidatos a extender la clique actual, asi sucesivamente hasta no encontrar mas candidatos a extender la clique que tiene formada actualmente, en ese punto va a volver hacia atras, quitando el ultimo nodo que se agrego a la clique, y eligiendo el proximo nodo que sea candidato si es que lo hubiera. El orden lexicografico es garantizado al momento de elegir los candidatos, ya que solo elegira aquellos candidatos cuyo numero de nodo sea mayor al numero de nodo del ultimo nodo que fue agregado a la clique.

A continuacion se expone el pseudo-codigo del algoritmo:

Variables globales: \textbf{Conj(nodo)} $cliqueMaxima$, \textbf{Entero} $fronteraMaxima$.\\

\begin{algorithm}[H]
	\SetAlgoLined
	\caption{Exacto}
	\KwIn{\textbf{Grafo} $g$} %esto hay que ponerlo bien
	\KwOut{\textbf{Conj(nodo)} $clique$}

	\textbf{Conj(nodo)} $clique = \emptyset$\\
	\textbf{Conj(nodo)} $candidatos = $ nodos($g$)\\

	Backtracking($clique$, $candidatos$)\\

	\textbf{devuelvo} $cliqueMaxima$\\

\end{algorithm}

\begin{algorithm}[H]
	\SetAlgoLined
	\caption{Backtracking}
	\KwIn{\textbf{Conj(nodo)} $clique$, \textbf{Conj(nodo)} $candidatos$, \textbf{Grafo} $g$} %esto hay que ponerlo bien
	\KwOut{\textbf{Conj(nodo)} $clique$}

	\For{$c \in candidatos$}{
		\If{\textbf{frontera}($ clique \cup \{c\} $) es mayor a $fronteraMaxima$ }{
			$cliqueMaxima = clique \cup \{c\} $\\
			$fronteraMaxima = $frontera($clique \cup \{c\}$)\\
		}
		\If{\textbf{frontera}($ clique \cup \{c\} $) $>$ \textbf{frontera}($clique$)}{
			Backtracking($ clique \cup \{c\} $, calcularCandidatos($ clique \cup \{c\} $), $g$, $c$)\\
		}
	}
\end{algorithm}

\begin{algorithm}[H]
	\SetAlgoLined
	\caption{frontera}
	\KwIn{\textbf{Conj(nodo)} $clique$, \textbf{Grafo} $g$} %esto hay que ponerlo bien
	\KwOut{\textbf{Entero} $res$}

	$res = 0$\\
	\For{\textbf{nodo} $v \in nodos(g)$}{
		$res = res + (\#adyacentes(v) - (\#clique - 1))$\\
	}

	\textbf{devuelvo} $res$\\

\end{algorithm}

\begin{algorithm}[H]
	\SetAlgoLined
	\caption{calcularCandidatos}
	\KwIn{\textbf{Conj(nodo)} $clique$, \textbf{Grafo} $g$, \textbf{Nodo} $ultimoNodoAgregado$} %esto hay que ponerlo bien
	\KwOut{\textbf{Conj(nodo)} $candidatos$}

	nodo $w$ = un elemento de $clique$\\

	$candidatos = adyacentes(w)$\\
	\For{\textbf{todo nodo} $v \in nodos(g), v \neq w$}{
		$candidatos$ = interseccion entre $adyacentes(v)$ y $candidatos$\\
	}

	quitar de $candidatos$ todos los nodos menores numericamente a $ultimoNodoAgregado$

	\textbf{devuelvo} $candidatos$\\

\end{algorithm}

En este caso el programa comienza con la funcion Exacto, esta es la encargada de crear los valores inciales con los cuales se va a llamara a la funcion backtracking, luego esta hace las llamdas recursivas para ir creando las diferentes cliques y sus candidatos teniendo en cuenta el orden lexicografico y en cada paso chequeando si las cliques que considera son mejores que la mejor encontrada actualmente. \\
La funcion $calcularCandidatos$ busca aquellos nodos que no son los de la clique actual pero que estan conectados con todos ellos, eso se logra calculando la interseccion entre los nodos adyacentes a los nodos de la clique. \\
La funcion $frontera$ devuelve el valor numerico de la frontera de una clique, como tenemos por pre-condicion que todo conjunto de nodos que reciba como parametro la funcion es una clique, entonces calcular la frontera se puede hacer restandole a la cantidad de nodos adyacentes de cada nodo la cantidad de nodos de la clique menos 1. 

\subsection{Analisis de complejidad}

El analisis de complejidad del algoritmo posee una cota superior definida por la funcion recursiva de backtracking, esta funcion se pueden analizar calcular el arbol de soluciones del problema en cuestion. Como buscamos cliques y puede haber cliques de tamaño 1 hasta tamaño $n$ inclusive, entonces el arbol de soluciones va a tener un tamaño de 