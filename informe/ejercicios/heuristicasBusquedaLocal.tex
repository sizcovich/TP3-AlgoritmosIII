\subsection{Explicación del algoritmo realizado}
Los algoritmos de búsqueda local parten de una solución inicial $S_{0}$ y en cada paso intentan mejorarla. Para esto, se calculan todas las posibles variaciones de $S_{0}$ que forman una solución al problema. Al conjunto de todas estas se lo llama vecindad. 
Estos algoritmos se ejecutan siempre y cuando exista una solución, perteneciente a la vecindad, que sea mejor a la que ya teníamos. \newline \newline
Para nuestro ejercicio, utilizamos como $S_{0}$ al nodo 1. Dicha elección se debió a que un nodo forma una clique, con lo cual es una posible solución a nuestro problema. Además, sabemos que este existe para cualquier grafo ya que la menor cantidad de nodos que se pueden ingresar en nuestro programa es uno. 
\newline Por otro lado, decidimos definir como vecindad a todas las posibles cliques que difieran en a lo sumo un nodo con nuestro $S_{0}$. Esta decision la tomamos para que nuestra clique no quede fija alrededor del nodo inicial. Para evitarnos tener que almacenar todas las posibles cliques para posteriormente elegir la mejor, decidimos separar la vecindad en tres subconjuntos. Estos se formaron con las cliques que cumplen lo siguiente:
\begin{itemize}
\item \textbf{Tiene todos los nodos de $S_{0}$ salvo 1:} \newline En lugar de calcular todas las posibles cliques de este subconjunto, decidimos quedarnos únicamente con la clique que se obtiene de quitarle el nodo de menor grado a $S_{0}$. Esto se debe a que la frontera de una clique se puede calcular con la siguiente formula:\newline
Sea $S_{0}$ = ($V$,$E$) y n = $|$$V$$|$
\begin{equation}
  \delta(S_{0}) = \sum_{v \in V}^{} d(v) - n*(n-1)
\end{equation}
Ahora, si quitamos un nodo $v'$ de $S_{0}$, obtenemos lo siguiente:
\begin{equation}
  \delta(S'_{0}) = \sum_{v \in V/v'}^{} d(v) - (n-1)*(n-2)
\end{equation}
Como nosotros queremos encontrar el mayor \delta$(S'_{0})$, debemos quedarnos con el que tiene la sumatoria de mayor valor ya que (n-1)*(n-2) es igual para todas las cliques. Con lo cual, el nodo que debemos eliminar para poder maximizar la sumatoria, es el de menor grado.

El pseudo codigo de este subconjunto de la vecindad es:\newline
\begin{algorithm}[H]
    \SetAlgoLined
    \caption{quitarNodo}
    \KwIn{\textbf{Grafo} $grafo$, \textbf{Conj(Entero)} $clique$}
    \KwOut{\textbf{par(Entero,Conj(Entero))} $res$}
	
    \textbf{Entero} $minimo$ = $|$vecindad(0)$|$ \\	
    \textbf{Entero} $minimoNodo = 0$ \\
    \ForAll{$v \in$ Nodos($clique$)}{
        $aux$ = $|$vecindad($v$)$|$ \\
		\If{$aux < minimo$}{
            $minimo$ = $aux$
			$minimoNodo$ = $v$
	 		}}
    
    \textbf{Conj(Entero)} $cliqueQuitando$\\

    \ForAll{$v \in$ Nodos($clique$)}{
		\If{$v \neq minimoNodo$}{
            agregar($cliqueQuitando$, $v$)
	 		}}
    
    \textbf{Entero} $fronteraRes$ = frontera($grafo$, $cliqueQuitando$)\\
    $res$ = hacerPar($cliqueQuitando$, $fronteraRes$)\\
    \textbf{devolver} $res$ \\
\end{algorithm}

Donde $frontera$ calcula la frontera del subgrafo pasado por parametro, $Nodos$ devuelve todos los nodos del subgrafo y $agregar$ inserta un elemento en un arreglo. \newline


\item \textbf{Tiene todos los nodos de $S_{0}$ más uno que no pertenecía a el:} \newline
Para poder obtener la clique de frontera máxima de este subconjunto, buscamos todos los nodos del grafo que pueden formar una clique con $S_{0}$. Para esto, contamos cuantos nodos de la clique se conectan a cada nodo del grafo. Si un nodo es alcanzado por todos los que pertenecen a $S_{0}$, entonces ese nodo forma una clique. Una vez que tenemos a todos los posibles candidatos, calculamos la frontera de cada uno y nos quedamos con la mayor. \newline

\begin{algorithm}[H]
    \SetAlgoLined
    \caption{agregarNodo}
    \KwIn{\textbf{Grafo} $grafo$, \textbf{Conj(Entero)} $clique$}
    \KwOut{\textbf{par(Entero,Conj(Entero))} $res$}
	
    \textbf{Conj(Entero)} $bucket[$nodos($grafo$)$] = 0$  \\
	
    \ForAll{$u \in$ Nodos($clique$)}{
	\ForAll{$v \in$ vecindad($u$)}{
		$bucket[v]$++
	 		}}

    \ForAll{$u \in$ Nodos($clique$)}{
	$bucket[u] = 0$
	}
	
    \textbf{Conj(Entero)} $posibleClique$ \\
    \ForAll{$u \in$ Nodos($grafo$)}{
	\If{$bucket[u] = |clique|$}{
            agregar($posibleClique$, $u$)
	 		}}

    \textbf{Entero} $maxFrontera = 0$ \\
    \textbf{Entero} $nodo = 0$ \\

    \ForAll{$v \in$ Nodos($posibleClique$)}{
	agregar($clique$, $v$) \\
		\If{frontera($clique$) $> maxFrontera$}{
		    $maxFrontera = $ frontera($clique$)\\
		    $nodo = v$
	}
	quitar($clique$, $v$) \\}


    \eIf{ $|posibleClique| =$ 0}
	{$res$ = hacerPar(0, $clique$)}
    {	agregar($clique$, $v$) \\
	$res$ = hacerPar($maxFrontera$, $clique$) }

    \textbf{devolver} $res$ \\
\end{algorithm}
\newline
\item \textbf{Tiene todos los nodos de $S_{0}$ salvo 1 que se lo reemplaza por otro que no estaba en el:} \newline
En este subconjunto lo primero que hicimos fue quitar un nodo de $S_{0}$ y posteriormente, con la clique que nos quedo, agregarle otro. Para esto, utilizamos la clique que obtuvimos en el primer subconjunto y luego, utilizamos la funcion que nos calculaba el subconjunto anterior para agregar el nuevo nodo. Al hacer esto, logramos que nuestra clique no quede centrada en el nodo de mayor grado ya que este eventualmente podria dejar de formar parte de la solucion. \newline
\begin{algorithm}[H]
    \SetAlgoLined
    \caption{agregarNodo}
    \KwIn{\textbf{Grafo} $grafo$, \textbf{Conj(Entero)} $clique$}
    \KwOut{\textbf{par(Entero,Conj(Entero))} $res$}
	
    $clique$ = segundo(quitarNodo($grafo$, $clique$)) \\
    \textbf{Conj(Entero)} $cliqueRes$ \\
    \eIf{$|clique| = 0$}{
	    \textbf{Entero} $nodo$ = nodoDeMayorGrado($grafo$) \\
            agregar($cliqueRes$, $nodo$)\\
	    $res$ = hacerPar (vecindad($nodo$), $cliqueRes$)	
	 		}{$res$ = agregarNodo($grafo$, $clique$)}

    \textbf{devolver} $res$ \\
\end{algorithm}
\newline
\end{itemize}

Una vez que generamos a los tres candidatos de la vecindad, tomamos al que tiene mayor frontera y lo comparamos con $S_{0}$. Si la frontera de $S_{0}$ es menor, entonces la clique de frontera maxima de nuestra vecindad es nuestra nueva solución inicial. Caso contrario, el programa finaliza ya que ningún elemento de la vecindad puede mejorarla.

\subsection{Complejidad Temporal}
\subsection{Instancias problemáticas}
\subsection{Experimentación}

