\subsection{Explicación del algoritmo realizado}
Los algoritmos de búsqueda local parten de una solución inicial $S_{0}$ y en cada paso intentan mejorarla. Para esto, se calculan todas las posibles variaciones de $S_{0}$ que forman una solución al problema. Al conjunto de todas estas se lo llama vecindad. 
Estos algoritmos se ejecutan siempre y cuando exista una solución, perteneciente a la vecindad, que sea mejor a la que ya teníamos. \newline \newline
Para nuestro ejercicio, utilizamos como $S_{0}$ al nodo de mayor frontera. Dicha elección se debió a que un nodo forma una clique, con lo cual es una posible solución a nuestro problema. Además, sabemos que este existe para cualquier grafo ya que la menor cantidad de nodos que se pueden ingresar en nuestro programa es uno. 
\newline Por otro lado, decidimos definir como vecindad a todas las posibles cliques que difieran en a lo sumo un nodo con nuestro $S_{0}$. Esta decision la tomamos para que nuestra clique no quede fija alrededor del nodo inicial. Para evitarnos tener que almacenar todas las posibles cliques para posteriormente elegir la mejor, decidimos separar la vecindad en tres subconjuntos. Estos se formaron con las cliques que cumplen lo siguiente:
\begin{itemize}
\item \textbf{Tiene todos los nodos de $S_{0}$ salvo 1:} \newline En lugar de calcular todas las posibles cliques de este subconjunto, decidimos quedarnos únicamente con la clique que se obtiene de quitarle el nodo de menor grado a $S_{0}$. Esto se debe a que la frontera de una clique se puede calcular con la siguiente formula:\newline
Sea $S_{0}$ = ($V$,$E$) y n = $|$$V$$|$
\begin{equation}
  \delta(S_{0}) = \sum_{v \in V}^{} d(v) - n*(n-1)
\end{equation}
Ahora, si quitamos un nodo $v'$ de $S_{0}$, obtenemos lo siguiente:
\begin{equation}
  \delta(S'_{0}) = \sum_{v \in V/v'}^{} d(v) - (n-1)*(n-2)
\end{equation}
Como nosotros queremos encontrar el mayor \delta$(S'_{0})$, debemos quedarnos con el que tiene la sumatoria de mayor valor ya que (n-1)*(n-2) es igual para todas las cliques. Con lo cual, el nodo que debemos eliminar para poder maximizar la sumatoria, es el de menor grado.

El pseudo codigo de este subconjunto de la vecindad es:\newline
\begin{algorithm}[H]
    \SetAlgoLined
    \caption{quitarNodo}
    \KwIn{\textbf{Grafo} $grafo$, \textbf{Conj(Entero)} $clique$}
    \KwOut{\textbf{par(Entero,Conj(Entero))} $res$}
	
    \textbf{Entero} $minimo$ = $|$vecindad(0)$|$ \\	
    \textbf{Entero} $minimoNodo = 0$ \\
    \ForAll{$v \in$ $|clique|$}{
        $aux$ = $|$vecindad($v$)$|$ \\
		\If{$aux < minimo$}{
            $minimo$ = $aux$ \\
			$minimoNodo$ = $v$
	 		}}
    
    \textbf{Conj(Entero)} $cliqueQuitando$\\

    \ForAll{$v \in$ $|clique|$}{
		\If{$v \neq minimoNodo$}{
            agregar($cliqueQuitando$, $v$)
	 		}}
    
    \textbf{Entero} $fronteraRes$ = frontera($grafo$, $cliqueQuitando$)\\
    $res$ = hacerPar($fronteraRes$, $cliqueQuitando$)\\
    \textbf{devolver} $res$ \\
\end{algorithm}

Donde $frontera$ calcula la frontera del subgrafo pasado por parametro, $agregar$ inserta un elemento en un arreglo, $vecindad$ nos devuelve todos los nodos adyacentes al nodo pasado por parametro y $hacerPar$ genera un par con lo dos elementos pasados por parametro. \newline


\item \textbf{Tiene todos los nodos de $S_{0}$ más uno que no pertenecía a el:} \newline
Para poder obtener la clique de frontera máxima de este subconjunto, buscamos todos los nodos del grafo que pueden formar una clique con $S_{0}$. Para esto, contamos cuantos nodos de la clique se conectan a cada nodo del grafo. Si un nodo es alcanzado por todos los que pertenecen a $S_{0}$, entonces ese nodo forma una clique. Una vez que tenemos a todos los posibles candidatos, calculamos la frontera de cada uno y nos quedamos con la mayor. \newline

\begin{algorithm}[H]
    \SetAlgoLined
    \caption{agregarNodo}
    \KwIn{\textbf{Grafo} $grafo$, \textbf{Conj(Entero)} $clique$}
    \KwOut{\textbf{par(Entero,Conj(Entero))} $res$}
	
    \textbf{Conj(Entero)} $bucket[$Nodos($grafo$)$] = 0$  \\
	
    \ForAll{$u \in$ Nodos($clique$)}{
	\ForAll{$v \in$ vecindad($u$)}{
		$bucket[v]$++
	 		}}

    \ForAll{$u \in$ Nodos($clique$)}{
	$bucket[u] = 0$
	}
	
    \textbf{Conj(Entero)} $posibleClique$ \\
    \ForAll{$u \in$ Nodos($grafo$)}{
	\If{$bucket[u] = |clique|$}{
            agregar($posibleClique$, $u$)
	 		}}

    \textbf{Entero} $maxFrontera = 0$ \\
    \textbf{Entero} $nodo = 0$ \\

    \ForAll{$v \in$ Nodos($posibleClique$)}{
	agregar($clique$, $v$) \\
		\If{frontera($clique$) $> maxFrontera$}{
		    $maxFrontera = $ frontera($clique$)\\
		    $nodo = v$
	}
	quitar($clique$, $v$) \\}


    \eIf{ $|posibleClique| =$ 0}
	{$res$ = hacerPar(0, $clique$)}
    {	agregar($clique$, $v$) \\
	$res$ = hacerPar($maxFrontera$, $clique$) }

    \textbf{devolver} $res$ \\
\end{algorithm}
Donde $frontera$ calcula la frontera del subgrafo pasado por parametro, $Nodos$ devuelve todos los nodos del subgrafo, $agregar$ inserta un elemento en un arreglo, $quitar$ quita un elemento en un arreglo, $vecindad$ nos devuelve todos los nodos adyacentes al nodo pasado por parametro y $hacerPar$ genera un par con lo dos elementos pasados por parametro. \newline

\item \textbf{Tiene todos los nodos de $S_{0}$ salvo 1 que se lo reemplaza por otro que no estaba en el:} \newline
En este subconjunto lo primero que hicimos fue quitar un nodo de $S_{0}$ y posteriormente, con la clique que nos quedo, agregarle otro. Para esto, utilizamos la funcion que quitaba un nodo a la clique y luego, utilizamos la funcion que nos calculaba el subconjunto anterior para agregar el nuevo nodo. Al hacer esto, logramos que nuestra clique no quede centrada en el nodo de mayor grado ya que este eventualmente podria dejar de formar parte de la solucion.
En el caso de que la clique tenga un solo elemento, dicidimos que este sea reemplazado por el nodo adyasente a el de mayor grado \newline
\begin{algorithm}[H]
    \SetAlgoLined
    \caption{permutarNodo}
    \KwIn{\textbf{Grafo} $grafo$, \textbf{Conj(Entero)} $clique$}
    \KwOut{\textbf{par(Entero,Conj(Entero))} $res$}
	
   \textbf{Conj(Entero)} $cliqueResultante$ = segundo(quitarNodo($grafo$, $clique$)) \\

    \eIf{$|cliqueResultante| = 0$}{
	    \textbf{Entero} $nodo$ = vecinoDeMayorGrado($grafo$,$clique[0]$) \\
            agregar($cliqueRes$, $nodo$)\\
	    $res$ = hacerPar ($|$vecindad($nodo$)$|$, $cliqueRes$)	
	 		}{$res$ = agregarNodo($grafo$, $clique$)}

    \textbf{devolver} $res$ \\
\end{algorithm}
Donde $segundo$ nos devuelve el segundo elemento de una tupla,  $agregar$ inserta un elemento en un arreglo, $vecinoDeMayorGrado$ nos da el nodo de mayor grado entre todos los vecinos del vertice pasado por parametro, $vecindad$ nos devuelve todos los nodos adyacentes al nodo pasado por parametro y $hacerPar$ genera un par con lo dos elementos pasados por parametro. \newline
\end{itemize}

Una vez que generamos a los tres candidatos de la vecindad, tomamos al que tiene mayor frontera y lo comparamos con $S_{0}$. Si la frontera de $S_{0}$ es menor, entonces la clique de frontera maxima de nuestra vecindad es nuestra nueva solución inicial. Caso contrario, el programa finaliza ya que ningún elemento de la vecindad puede mejorarla.

\subsection{Complejidad Temporal}
Para analizar la complejidad de nuestro algoritmo, vamos a separarlo en 5 funciones:
\begin{itemize}
\item \textbf{Generar grafo:} \newline
Para poder generar un grafo con los parametros de entrada, utilizamos una lista y una matriz de adyacencia para poder obtener la mayoria de las operaciones en $\mathcal{O}(1)$ y asi no aumentar la complejidad de nuestro algoritmo. Por consiguiente, la complejidad es $\mathcal{O}(n^{2})$.

\item \textbf{quitarNodo:} \newline
Como podemos observar en el pseudocodigo Nº 6, lo primero que hace nuestro algoritmo es calcular $vecindad$ del nodo 0, la cual tiene una complejidad $\mathcal{O}(1)$. Posteriormente, hay un ciclo el cual consiste en recorrer todos los nodos de la clique($\mathcal{O}(n)$) y almacenar el de menor grado en cada paso ($\mathcal{O}(1)$).
\newline
Luego, hay un ciclo el cual nuevamente recorre todos los nodos de la clique ($\mathcal{O}(n)$) y en cada paso utiliza la funcion $agregar$ la cual fue implementada con $push_back$\footnote{http://www.cplusplus.com/reference/vector/vector/push\_back/} con una complejidad de $\mathcal{O}(1)$.
\newline
Por ultimo, se calcula el valor de la frontera mediante la funcion $frontera$ la cual tiene una complejidad de $\mathcal{O}(n)$ y se genera un par con la solucion del problema. Este par es generado mediante la funcion $make\_pair$\footnote{http://www.cplusplus.com/reference/utility/make\_pair/} cuya complejidad es $\mathcal{O}(1)$.
\newline
Como se puede observar, la complejidad final de $quitarNodo$ es $\mathcal{O}(n)$

\item \textbf{agregarNodo:} \newline 
Como podemos observar en el pseudocodigo Nº 7, lo primero que hace nuestro algoritmo es crear un arreglo de n pocisiones ($\mathcal{O}(n)$)en donde va a marcar, para cada nodo, cuantos adyacentes pertenecen a la clique. Luego, recorre cada nodo de la clique y le suma uno a cada uno de sus vecinos ($\mathcal{O}(n^{2})$). Por ultimo, recorre todos los nodos de la clique y coloca su posicion en el arreglo en 0 para que no figuren como posibles candidatos ($\mathcal{O}(n)$). \newline
Una vez hecho esto, agrega en un arreglo, mediante la funcion $push_back$,\footnote{http://www.cplusplus.com/reference/vector/vector/push\_back/} todos los nodos que pueden formar una clique. Finalmente, compara la frontera ($\mathcal{O}(n)$) de todas las posibles soluciones agregando (con $push_back$\footnote{http://www.cplusplus.com/reference/vector/vector/push\_back/}) y quitando (con $pop_back$\footnote{http://www.cplusplus.com/reference/vector/vector/pop\_back/} cuya complejidad es $\mathcal{O}(1)$) los nodos que formaban una clique con la que teniamos anteriormente. el costo de realizar esto es $\mathcal{O}(n^{2})$. \newline
Una vez que tiene la solucion, genera un par con esta mediante la funcion $make\_pair$\footnote{http://www.cplusplus.com/reference/utility/make\_pair/} cuya complejidad es $\mathcal{O}(1)$.
\newline
Como se puede observar, la complejidad final de $agregarNodo$ es $\mathcal{O}(n^{2})$

\item \textbf{permutarNodo:} \newline 
Como podemos observar en el pseudocodigo Nº 8, nuestro algoritmo hace dos cosas. Primero le quita un nodo a la clique mediante la funcion $quitarNodo$ cuya complejidad es $\mathcal{O}(n)$. Posteriormente, se fija si el resultado de $quitarNodo$ es vacio o no. \newline
En el caso de que sea vacio, calcula mediante $vecinoDeMayorGrado$ cual de todos los nodos adyacentes al pasado por parametro tiene mayor grado. Para esto, recorre todos los nodos adyacentes y compara en $\mathcal{O}(1)$ sus grados, por lo tanto su complejidad es $\mathcal{O}(n)$. Una vez que tiene la solucion, la coloca en un arreglo mediante $push_back$\footnote{http://www.cplusplus.com/reference/vector/vector/push\_back/} y genera un par con esta mediante la funcion $make\_pair$\footnote{http://www.cplusplus.com/reference/utility/make\_pair/} cuya complejidad es $\mathcal{O}(1)$.
\newline
Si por el contrario, la clique no estaba vacia, obtiene la solucion mediante la funcion $agregarNodo$ cuya complejidad es $\mathcal{O}(n^{2})$
\newline
Como se puede observar, la complejidad final de $permutarNodo$ es $\mathcal{O}(n^{2})$

\item \textbf{busquedaLocal:} \newline 

\begin{algorithm}[H]
    \SetAlgoLined
    \caption{busquedaLocal}
    \KwIn{\textbf{Grafo} $grafo$, \textbf{Entero} $m$}
    \KwOut{\textbf{Conj(Entero)} $res$}
	
    agregar($res$, nodoDeMayorGrado($grafo$))\\
    	
    \For{i = 0  \textbf{to} i $<$ m}{
        \textbf{par(Entero, Conj(Entero))} $aux = $ agregarNodo($grafo, res$)\\
	\If{primero($aux$)$ < $primero(quitarNodo($grafo$, $res$))}{
            $aux = $ quitarNodo($grafo$, $res$)\\
	 		}
    	\If{primero($aux$)$ < $primero(permutarNodo($grafo$, $res$))}{
            $aux = $ permutarNodo($grafo$, $res$)\\
	 		}
	\eIf{primero($aux$)$ > $frontera($res$)}{
            $res = $ primero($aux$)\\
	 		}{$salir del ciclo$}
	}
    \textbf{devolver} $res$ \\
\end{algorithm}

LLEGUE HASTA ACA!!!!!!!!!!!!!!!!!!!!!!!!!!!

Como podemos observar en el pseudocodigo Nº 8, nuestro algoritmo hace dos cosas. Primero le quita un nodo a la clique mediante la funcion $quitarNodo$ cuya complejidad es $\mathcal{O}(n)$. Posteriormente, se fija si el resultado de $quitarNodo$ es vacio o no. \newline
En el caso de que sea vacio, calcula mediante $vecinoDeMayorGrado$ cual de todos los nodos adyacentes al pasado por parametro tiene mayor grado. Para esto, recorre todos los nodos adyacentes y compara en $\mathcal{O}(1)$ sus grados, por lo tanto su complejidad es $\mathcal{O}(n)$. Una vez que tiene la solucion, la coloca en un arreglo mediante $push_back$\footnote{http://www.cplusplus.com/reference/vector/vector/push\_back/} y genera un par con esta mediante la funcion $make\_pair$\footnote{http://www.cplusplus.com/reference/utility/make\_pair/} cuya complejidad es $\mathcal{O}(1)$.
\newline
Si por el contrario, la clique no estaba vacia, obtiene la solucion mediante la funcion $agregarNodo$ cuya complejidad es $\mathcal{O}(n^{2})$
\newline
Como se puede observar, la complejidad final de $permutarNodo$ es $\mathcal{O}(n^{2})$


\subsection{Instancias problemáticas}
\subsection{Experimentación}

