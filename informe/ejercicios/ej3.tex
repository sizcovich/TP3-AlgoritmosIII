\subsection{Heurística Constructiva Golosa}
Idea:
\begin{itemize}
\item Agarro nodo $v$ de mayor grado
\item Meto $v$ en la bolsa de nodos seleccionados
\item Agarro el nodo de mayor grado adyacente a $v$ que forme una clique con todos los de la bolsa y que tenga mayor frontera
\item Meto en la bolsa el elegido
\item vuelvo al segundo 'Agarro' hasta que ninguno cumpla la clique
\end{itemize}


Hay que decir que es asíntico, que se rompe muy fácil, como por ejemplo cuando la clique de maxima frontera no contiene al nodo de mayor grado.

\subsection{Heurística de Búsqueda Local}

Los algoritmos de búsqueda local parten de una solución inicial $S_{0}$ y en cada paso intentan mejorarla. Para esto, se calculan todas las posibles variaciones de $S_{0}$ que forman una solucion al problema. Al conjunto de todas estas se lo llama vecindad. 
Estos algoritmos se ejecutan siempre y cuando exista una solucion, perteneciente a la vecindad, que sea mejor a la que ya teniamos. \newline \newline
Para nuestro ejercicio, utilizamos como $S_{0}$ al nodo 1. Dicha eleccion se debio a que un nodo forma una clique, con lo cual es una posible solucion a nuestro problema. Ademas, sabemos que este existe para cualquier grafo ya que la menor cantidad de nodos que se pueden ingresar en nuestro programa es uno. Por otro lado, definimos como vecindad a todos los posibles conjuntos de nodos que forman una clique y cumplen lo siguiente:
\begin{itemize}
\item Tiene todos los nodos de $S_{0}$ salvo 1: \newline El nodo que se elimina de la clique es aquel cuyo grado es el menor de todos. 
\item Tiene todos los nodos de $S_{0}$ mas uno que no pertenecia a $S_{0}$.
\item Tiene todos los nodos de $S_{0}$ salvo 1 que se lo reemplaza por uno que no estaba en $S_{0}$. Esto significa que agrego un nodo y quito otro.
\end{itemize}
Una vez que generamos la vecindad, tomamos la clique de mayor frontera, $S_{maxima}$ y la comparamos con $S_{0}$. Si la frontera de $S_{0}$ es menor, $S_{maxima}$ es nuestra nueva solucion inicial. Caso contrario, el programa finaliza ya que ningun elemento de la vecindad puede mejorar nuestra solucion.



%no entendi esto! 
%Hay que ver cuánto dura cada vértice en cantidad de ejecuciones.


\subsection{Heurística de Búsqueda Tabú}

\begin{algorithm}[H]
    \SetAlgoLined
    \caption{TabuSearch}
    \KwIn{\textbf{Conj(nodos)} $solucion$\_$inicial$, \textbf{Grafo} $g$, \textbf{Entero} $cantidad$\_$pasos$, \textbf{Entero} $desviacion$\_$permitida$}
    \KwOut{\textbf{Conj(nodos)} $solucion$\_$final$}
		
	\textbf{Entero} desviacion$\_$permitida$\_$aux = 0 \\
	\textbf{Conj(nodos)} $solucion$\_$final$ = $solucion$\_$inicial$ \\
		
	\textbf{Mientras} ($cantidad$\_$pasos$ $>$ 0) \\
	\hspace{4mm} \textbf{Hacer} \\
	\hspace{8mm}     \textbf{Entero} $frontera$\_$ini$ = frontera($solucion$\_$inicial$) \\
	\hspace{8mm} \textbf{Para} ( u \in Candidatos$\_$clique(g,u) ) \\
	\hspace{12mm} \textbf{Si} ( $\neg$ es tabu(u) $\wedge$ $\neg$ esta agregado $u$ en $solucion$\_$inicial$ ) \\
	\hspace{16mm} \textbf{Si} (frontera($solucion$\_$final$) $<$ Frontera con $u$ en $solucion$\_$inicial$) \\
	\hspace{20mm}  $solucion$\_$final$ = $solucion$\_$inicial$ con $u$ \\
	\hspace{16mm} \textbf{Sino} \\
	\hspace{20mm}  \textbf{Si} (desviacion$\_$permitida$\_$aux $>$ 0) \\
	\hspace{24mm} $solucion$\_$inicial$ = $solucion$\_$inicial$ con $u$ \\
	\hspace{24mm} Poner en lista Tabu a $u$ \\
	\hspace{24mm} $desviacion$\_$permitida$\_$aux$  - 1 \\
	\hspace{8mm} \textbf{Fin Para} \\
	\hspace{8mm} \textbf{Para} ( u \in Nodos($solucion$\_$inicial$) ) \\
	\hspace{12mm} \textbf{Si} ( \neg es tabu(u) ) \\
	\hspace{16mm} \textbf{Si }(frontera($solucion$\_$final$) $<$ Frontera sin $u$ en $solucion$\_$inicial$) \\
	\hspace{20mm} $solucion$\_$final$ = $solucion$\_$inicial$ sin $u$ \\
	\hspace{16mm} \textbf{Sino} \\
	\hspace{20mm} \textbf{Si} ($desviacion$\_$permitida$\_$aux$ $>$ 0) \\
	\hspace{24mm} $solucion$\_$inicial$ = $solucion$\_$inicial$ sin $u$ \\
	\hspace{24mm} Poner en lista Tabu a $u$ \\
	\hspace{24mm} $desviacion$\_$permitida$\_$aux$  - 1 \\
	\hspace{8mm} \textbf{Fin Para} \\
							
	\hspace{8mm} \textbf{Si} ($desviacion$\_$permitida$\_$aux$ \leq 0) \\
	\hspace{12mm} $solucion$\_$inicial$ = $solucion$\_$final$ \\
	\hspace{4mm} \textbf{Mientras}( $frontera$\_$ini$ $<$ frontera($solucion$\_$final$)  $\vee$ $desviacion$\_$permitida$\_$aux$ $>$ 0 ) \\
	\hspace{4mm} $desviacion$\_$permitida$\_$aux$ = $desviacion$\_$permitida$  \\
	\hspace{4mm} Vaciamos la lista Tabu \\
	\hspace{4mm} Agregamos los ultimos dos nodos de $solucion$\_$final$ a la lista Tabu \\
	\hspace{4mm} $cantidad$\_$pasos$ - 1 \\
 	\textbf{Fin Mientras} \\
    	\textbf{devolver} $solucion$\_$final$ \\
		
\end{algorithm}

Donde:
\begin{itemize}
 \item $desviacion$\_$permitida$ dice la cantidad de veces que se agrega o quita un nodo por iteracion (empeorando la solucion parcial).
 \item $cantidad$\_$pasos$ son la cantidad de veces que se aplica el algoritmo. Tener en cuenta que la primera iteracion $desviacion$\_$permitida$ es 0, por lo que se toma el maximo local.
 \item frontera : Dice, dada una solucion como parametro, el numero de nodos adyacentes a la frontera (es lo que pide maximizar el enunciado).
 \item Candidatos$\_$clique : Dice los nodos que pertenecen a la clique del nodo pasado como parametro.
 \item Nodos : da los nodos pertenecientes a la solucion pasada como parametro.
\end{itemize}
