\subsection{Heurística Constructiva Golosa}
Para resolver el algoritmo presentado anteriormente con una técnica golosa, decidimos utilizar el procedimiento que se presenta a continuación:\newline
\newline
\begin{algorithm}[H]
    \SetAlgoLined
    \caption{HeurísticaGolosa}
    \KwIn{\textbf{Entero} $cantVertices$, \textbf{Entero} $cantAristas$, \textbf{Grafo} $g$} %esto hay que ponerlo bien
    \KwOut{\textbf{Conj(nodos)} $clique$}
	Entero $nodoDeMayorGrado$ = nodoDeMasGrado($g$)\\
	Grafo $cliqueHastaAhora$ = $\emptyset$\\
	agregar($v$, $cliqueHastaAhora$)\\
	\ForAll{$u \in$ adyacentes(nodoDeMayorGrado, nodos($g$))}{
		\If{forma una clique($g$, agregar($u$, $cliqueHastaAhora$)) $\land$ frontera($g$, agregar($u$, $cliqueHastaAhora$) $>$ frontera($cliqueHastaAhora$)}{
		agregar($u$, $cliqueHastaAhora$)}}
\textbf{devolver} $cliqueHastaAhora$
\end{algorithm}

donde $nodoDeMasGrado$ consiste en una función que toma el nodo del grafo cuyo grado es el mayor, $frontera$ es una función que calcula la frontera de un conjunto de nodos dentro de un grafo y $adyacentes$ consiste en una lista de nodos adyacentes a un determinado nodo.\newline


Hay que decir que es asíntico, que se rompe muy fácil, como por ejemplo cuando la clique de maxima frontera no contiene al nodo de mayor grado.

\subsection{Heurística de Búsqueda Local}

Los algoritmos de búsqueda local parten de una solución inicial $S_{0}$ y en cada paso intentan mejorarla. Para esto, se calculan todas las posibles variaciones de $S_{0}$ que forman una solución al problema. Al conjunto de todas estas se lo llama vecindad. 
Estos algoritmos se ejecutan siempre y cuando exista una solución, perteneciente a la vecindad, que sea mejor a la que ya teníamos. \newline \newline
Para nuestro ejercicio, utilizamos como $S_{0}$ al nodo 1. Dicha elección se debió a que un nodo forma una clique, con lo cual es una posible solución a nuestro problema. Además, sabemos que este existe para cualquier grafo ya que la menor cantidad de nodos que se pueden ingresar en nuestro programa es uno. 
\newline Por otro lado, decidimos separar la vecindad en 3 subconjuntos y para cada uno de estos, tomar la clique de mayor frontera. Al hacer esto, nos evitamos tener que almacenar todas las posibles cliques para posteriormente elegir la mejor. Los tres subconjuntos se formaron con las cliques que cumplen lo siguiente:
\begin{itemize}
\item \textbf{Tiene todos los nodos de $S_{0}$ salvo 1:} \newline En lugar de calcular todas las posibles cliques de este subconjunto, decidimos quedarnos únicamente con la clique que se obtiene de quitarle el nodo de menor grado a $S_{0}$. Esto se debe a que la frontera de una clique se puede calcular con la siguiente formula:\newline
Sea $S_{0}$ = ($V$,$E$) y n = $|$$V$$|$
\begin{equation}
  \delta(S_{0}) = \sum_{v \in V}^{} d(v) - n*(n-1)
\end{equation}
Ahora, si quitamos un nodo $v'$ de $S_{0}$, obtenemos lo siguiente:
\begin{equation}
  \delta(S'_{0}) = \sum_{v \in V/v'}^{} d(v) - (n-1)*(n-2)
\end{equation}
Como nosotros queremos encontrar el mayor \delta$(S'_{0})$, debemos quedarnos con el que tiene la sumatoria de mayor valor ya que (n-1)*(n-2) es igual para todas las cliques. Con lo cual, el nodo que debemos eliminar para poder maximizar la sumatoria, es el de menor grado.
\item \textbf{Tiene todos los nodos de $S_{0}$ mas uno que no pertenecía a $S_{0}$:} \newline
Para poder obtener la clique de frontera máxima de este subconjunto, buscamos todos los nodos del grafo que pueden formar una clique con $S_{0}$. Para esto, contamos cuantos nodos de la clique se conectan a cada nodo del grafo. Si un nodo es alcanzado por todos los que pertenecen a $S_{0}$, entonces ese nodo forma una clique. Una vez que tenemos a todos los posibles candidatos, calculamos la frontera de cada uno y nos quedamos con la mayor.
\item \textbf{Tiene todos los nodos de $S_{0}$ salvo 1 que se lo reemplaza por otro que no estaba en $S_{0}$:} \newline
\end{itemize}
Una vez que generamos la vecindad, tomamos la clique de mayor frontera, $S_{maxima}$ y la comparamos con $S_{0}$. Si la frontera de $S_{0}$ es menor, $S_{maxima}$ es nuestra nueva solución inicial. Caso contrario, el programa finaliza ya que ningún elemento de la vecindad puede mejorarla.



%no entendi esto! 
%Hay que ver cuánto dura cada vértice en cantidad de ejecuciones.


\subsection{Heurística de Búsqueda Tabú}

\begin{algorithm}[H]
    \SetAlgoLined
    \caption{TabuSearch}
    \KwIn{\textbf{Conj(nodos)} $solución\_inicial$, \textbf{Grafo} $g$, \textbf{Entero} $cantidad\_pasos$, \textbf{Entero} $desviacion\_permitida$}
    \KwOut{\textbf{Conj(nodos)} $solución\_final$}
		
	\textbf{Entero} $desviacion\_permitida\_aux$ = 0 \\
	\textbf{Conj(nodos)} $solución\_final$ = $solución\_inicial$ \\
		
	\While{$cantidad\_pasos >$ 0}{
		\textbf{Entero} $frontera\_ini$ = frontera($solución\_inicial$) \\
	 	\For{$u \in Candidatos\_clique(g,u)$}{
	 		\If{$\neg$ es tabu($u$) $\land \neg$ esta agregado $u$ en $solución\_inicial$}{
	 			\eIf{frontera($solución\_final$) $<$ Frontera con $u$ en $solución\_inicial$}{
					$solución\_final$ = $solución\_inicial$ con $u$}{
	  				\If{$desviacion\_permitida\_aux >$ 0}{
	 				$solución\_inicial$ = $solución\_inicial$ con $u$ \\
	 				Poner en lista Tabu a $u$ \\
	 				$desviacion\_permitida\_aux$ - 1}}}}}
	
	\ForAll{$u \in$ Nodos($solución$\_$inicial$)}{
		\If{$\neg$ es tabu($u$)}{
	 		\eIf{frontera($solución\_final$) $<$ Frontera sin $u$ en $solución\_inicial$}{
	 			$solución\_final$ = $solución\_inicial$ sin $u$}{
				\If{$desviacion\_permitida\_aux >$ 0}{
					$solución\_inicial$ = $solución\_inicial$ sin $u$ \\
					Poner en lista Tabu a $u$ \\
					$desviacion\_permitida\_aux$ - 1}}}}
							
	\If{$desviacion\_permitida\_aux \leq$ 0}{
		$solución\_inicial$ = $solución\_final$}
	\While{$frontera\_ini <$ frontera($solución\_final$) $\vee \ desviacion\_permitida\_aux >$ 0}{
		$desviacion\_permitida\_aux$ = $desviacion\_permitida$ \\
		Vaciar la lista Tabu \\
		Agregar los ultimos dos nodos de $solución\_final$ a la lista Tabu \\
		$cantidad\_pasos$ - 1}
    	\textbf{devolver} $solución\_final$ \\

\end{algorithm}

Donde:
\begin{itemize}
 \item $desviacion$\_$permitida$ dice la cantidad de veces que se agrega o quita un nodo por iteracion (empeorando la solución parcial).
 \item $cantidad$\_$pasos$ son la cantidad de veces que se aplica el algoritmo. Tener en cuenta que la primera iteracion $desviacion$\_$permitida$ es 0, por lo que se toma el maximo local.
 \item frontera : Dice, dada una solución como parametro, el numero de nodos adyacentes a la frontera (es lo que pide maximizar el enunciado).
 \item Candidatos$\_$clique : Dice los nodos que pertenecen a la clique del nodo pasado como parametro.
 \item Nodos : da los nodos pertenecientes a la solución pasada como parametro.
\end{itemize}
